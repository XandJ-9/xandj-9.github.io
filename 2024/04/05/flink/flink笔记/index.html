<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="角色架构Jobmanager Resourcemanager TaskManager Dispatcher  流处理API 1. Environment1.1 getExecutionEnvirionment​		创建执行环境，表示当前执行成勋的上下文。如果程序独立调用，则此方法返回本地执行环境；如果从命令行客户端调用程序以提交到集群，则此方法返回集群的执行环境，也就是说getExecutionE">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/04/05/flink/flink%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="角色架构Jobmanager Resourcemanager TaskManager Dispatcher  流处理API 1. Environment1.1 getExecutionEnvirionment​		创建执行环境，表示当前执行成勋的上下文。如果程序独立调用，则此方法返回本地执行环境；如果从命令行客户端调用程序以提交到集群，则此方法返回集群的执行环境，也就是说getExecutionE">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211130160920967.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211106234954325.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211107182703069.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211107181237261.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211107183043268.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211107230133974.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211107232313476.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211108005213438.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211108170754108.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/tumbling-windows.svg">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/sliding-windows.svg">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/session-windows.svg">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/non-windowed.svg">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211118002519387.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/stream_watermark_in_order.svg">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/stream_watermark_out_of_order.svg">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211118015453141.png">
<meta property="og:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211208011201234.png">
<meta property="article:published_time" content="2024-04-05T14:53:22.855Z">
<meta property="article:modified_time" content="2024-04-05T14:53:22.855Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/flink%E7%AC%94%E8%AE%B0.assets/image-20211130160920967.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-flink/flink笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/05/flink/flink%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2024-04-05T14:53:22.855Z" itemprop="datePublished">2024-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="角色架构"><a href="#角色架构" class="headerlink" title="角色架构"></a>角色架构</h1><p>Jobmanager</p>
<p>Resourcemanager</p>
<p>TaskManager</p>
<p>Dispatcher</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211130160920967.png" alt="image-20211130160920967"></p>
<h1 id="流处理API"><a href="#流处理API" class="headerlink" title="流处理API"></a>流处理API</h1><p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211106234954325.png" alt="image-20211106234954325"></p>
<h2 id="1-Environment"><a href="#1-Environment" class="headerlink" title="1. Environment"></a>1. Environment</h2><h3 id="1-1-getExecutionEnvirionment"><a href="#1-1-getExecutionEnvirionment" class="headerlink" title="1.1 getExecutionEnvirionment"></a>1.1 getExecutionEnvirionment</h3><p>​		创建执行环境，表示当前执行成勋的上下文。如果程序独立调用，则此方法返回本地执行环境；如果从命令行客户端调用程序以提交到集群，则此方法返回集群的执行环境，也就是说getExecutionEnvironment方法会根据查询运行的方式决定返回什么样的执行环境，这是最常用的创建执行环境的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">streamEnv</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>



<h3 id="1-2-createLocalEnvironment"><a href="#1-2-createLocalEnvironment" class="headerlink" title="1.2 createLocalEnvironment"></a>1.2 createLocalEnvironment</h3><p>​		返回本地的执行环境，可以在调用是指定默认的并行度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalStreamEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.createLocalEnvironment(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="1-2-createRemoteEnvironment"><a href="#1-2-createRemoteEnvironment" class="headerlink" title="1.2 createRemoteEnvironment"></a>1.2 createRemoteEnvironment</h3><p>​		返回集群执行环境，将jar提交到远程服务器，需要在调用时指定JobManager的IP和端口，并指定要在集群中运行的jar文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.createRemoteEnvironment(<span class="string">&quot;linux111&quot;</span>,<span class="number">6123</span>,<span class="string">&quot;jarfile.path&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="2-Source"><a href="#2-Source" class="headerlink" title="2. Source"></a>2. Source</h2><h3 id="2-1-从集合中读取数据"><a href="#2-1-从集合中读取数据" class="headerlink" title="2.1 从集合中读取数据"></a>2.1 从集合中读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceTest1_Collection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 设置并行度(可选)</span></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中获取数据</span></span><br><span class="line">        DataStreamSource&lt;SensorReading&gt; sensorDataStream = env.fromCollection(Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SensorReading</span>(<span class="string">&quot;sensor_1&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().getTime(), <span class="number">35.8</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SensorReading</span>(<span class="string">&quot;sensor_4&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().getTime(), <span class="number">34.2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SensorReading</span>(<span class="string">&quot;sensor_3&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().getTime(), <span class="number">37.4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SensorReading</span>(<span class="string">&quot;sensor_8&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().getTime(), <span class="number">30.9</span>)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素集合中获取元素</span></span><br><span class="line">        DataStreamSource&lt;Integer&gt; integerDataStream = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">67</span>, <span class="number">198</span>);</span><br><span class="line">        <span class="comment">// 打印到控制台</span></span><br><span class="line">        sensorDataStream.print(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        integerDataStream.print(<span class="string">&quot;int&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-2-从文件中读取数据"><a href="#2-2-从文件中读取数据" class="headerlink" title="2.2 从文件中读取数据"></a>2.2 从文件中读取数据</h3><p>​		使用readTextFile方法提供文件路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceTest2_File</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从文本文件中读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印到控制台</span></span><br><span class="line">        dataStream.print(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="comment">// 程序执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-从socket接口获取数据"><a href="#2-3-从socket接口获取数据" class="headerlink" title="2.3 从socket接口获取数据"></a>2.3 从socket接口获取数据</h3><p>​		socketTextStream方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;String&gt; dataStream = env.socketTextStream(<span class="string">&quot;linux111&quot;</span>, <span class="number">7777</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-4-从kafka中读取数据，作为来源"><a href="#2-4-从kafka中读取数据，作为来源" class="headerlink" title="2.4 从kafka中读取数据，作为来源"></a>2.4 从kafka中读取数据，作为来源</h3><p>​		添加kafka连接器的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- flink-connector-kafka-0.11_$&#123;scala版本&#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceTest3_Kafka</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// kafka消费配置</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>,<span class="string">&quot;linux111:9092&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;group.id&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置kafka connector，消费数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.addSource(<span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;String&gt;(<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), properties));</span><br><span class="line"></span><br><span class="line">        dataStream.print();</span><br><span class="line">        env.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-5-自定义Source"><a href="#2-5-自定义Source" class="headerlink" title="2.5 自定义Source"></a>2.5 自定义Source</h3><p>​		自定义Source有三种可以选择的SourceFunction：</p>
<ul>
<li>(implements) SourceFunction</li>
<li>(implements) ParallelSourceFunction  (并发)</li>
<li>(extends) RichParallelSourceFunction  (并发)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceTest4_UDF</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 添加自定的Source</span></span><br><span class="line"><span class="comment">//        DataStreamSource&lt;SensorReading&gt; dataStream = env.addSource(new MySensorSource());</span></span><br><span class="line">        DataStreamSource&lt;SensorReading&gt; dataStream = env.addSource(<span class="keyword">new</span> <span class="title class_">MySensorParallelSource</span>());</span><br><span class="line"><span class="comment">//        DataStreamSource&lt;SensorReading&gt; dataStream = env.addSource(new MySensorRichSource());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印到控制台</span></span><br><span class="line">        dataStream.print(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="comment">// 程序执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现SourceFunction接口来自定义Source</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySensorSource</span> <span class="keyword">implements</span> <span class="title class_">SourceFunction</span>&lt;SensorReading&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志，来控制数据的产生</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;SensorReading&gt; ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 随机生成数据</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            HashMap&lt;String, Double&gt; sensorTempMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sensorTempMap.put(<span class="string">&quot;sensor_&quot;</span> + i, random.nextGaussian());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据传递到流式集合中</span></span><br><span class="line">            <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String sensorId : sensorTempMap.keySet()) &#123;</span><br><span class="line">                    <span class="comment">// 制造随机波动</span></span><br><span class="line">                    <span class="type">Double</span> <span class="variable">newTemp</span> <span class="operator">=</span> sensorTempMap.get(sensorId) + random.nextGaussian();</span><br><span class="line">                    sensorTempMap.put(sensorId, newTemp);</span><br><span class="line">                    <span class="comment">// 生成数据,放入到上下文中</span></span><br><span class="line">                    ctx.collect(<span class="keyword">new</span> <span class="title class_">SensorReading</span>(sensorId, System.currentTimeMillis(), newTemp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">                isRunning = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ParallelSourceFunction接口来自定义Source</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySensorParallelSource</span> <span class="keyword">implements</span> <span class="title class_">ParallelSourceFunction</span>&lt;SensorReading&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志，来控制数据的产生</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;SensorReading&gt; ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 随机生成数据</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            HashMap&lt;String, Double&gt; sensorTempMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sensorTempMap.put(<span class="string">&quot;sensor_&quot;</span> + i, random.nextGaussian());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据传递到流式集合中</span></span><br><span class="line">            <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String sensorId : sensorTempMap.keySet()) &#123;</span><br><span class="line">                    <span class="comment">// 制造随机波动</span></span><br><span class="line">                    <span class="type">Double</span> <span class="variable">newTemp</span> <span class="operator">=</span> sensorTempMap.get(sensorId) + random.nextGaussian();</span><br><span class="line">                    sensorTempMap.put(sensorId, newTemp);</span><br><span class="line">                    <span class="comment">// 生成数据,放入到上下文中</span></span><br><span class="line">                    ctx.collect(<span class="keyword">new</span> <span class="title class_">SensorReading</span>(sensorId, System.currentTimeMillis(), newTemp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">                isRunning = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承RichParallelSourceFunction类实现自定义的Source</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySensorRichSource</span> <span class="keyword">extends</span> <span class="title class_">RichParallelSourceFunction</span>&lt;SensorReading&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志，来控制数据的产生</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;SensorReading&gt; ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 随机生成数据</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            HashMap&lt;String, Double&gt; sensorTempMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sensorTempMap.put(<span class="string">&quot;sensor_&quot;</span> + i, random.nextGaussian());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据传递到流式集合中</span></span><br><span class="line">            <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String sensorId : sensorTempMap.keySet()) &#123;</span><br><span class="line">                    <span class="comment">// 制造随机波动</span></span><br><span class="line">                    <span class="type">Double</span> <span class="variable">newTemp</span> <span class="operator">=</span> sensorTempMap.get(sensorId) + random.nextGaussian();</span><br><span class="line">                    sensorTempMap.put(sensorId, newTemp);</span><br><span class="line">                    <span class="comment">// 生成数据,放入到上下文中</span></span><br><span class="line">                    ctx.collect(<span class="keyword">new</span> <span class="title class_">SensorReading</span>(sensorId, System.currentTimeMillis(), newTemp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">                isRunning = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-Transform"><a href="#3-Transform" class="headerlink" title="3. Transform"></a>3. Transform</h2><p>转换算子</p>
<h3 id="3-1-map"><a href="#3-1-map" class="headerlink" title="3.1 map"></a>3.1 map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. map</span></span><br><span class="line">SingleOutputStreamOperator&lt;Integer&gt; mapOutputStream = inputStream.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 返回字符串的长度</span></span><br><span class="line">        <span class="keyword">return</span> value.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="3-2-flatMap"><a href="#3-2-flatMap" class="headerlink" title="3.2 flatMap"></a>3.2 flatMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.flatmap</span></span><br><span class="line">SingleOutputStreamOperator&lt;String&gt; flatMapOutputStream = inputStream.flatMap(<span class="keyword">new</span> <span class="title class_">FlatMapFunction</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(String value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] fields = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">            out.collect(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="3-3-filter"><a href="#3-3-filter" class="headerlink" title="3.3 filter"></a>3.3 filter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. filter 过滤</span></span><br><span class="line">SingleOutputStreamOperator&lt;String&gt; filterOutputStream = inputStream.filter(<span class="keyword">new</span> <span class="title class_">FilterFunction</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> value.startsWith(<span class="string">&quot;1,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<h3 id="3-4-keyBy"><a href="#3-4-keyBy" class="headerlink" title="3.4 keyBy"></a>3.4 keyBy</h3><h4 id="DataStream-→-KeyedStream"><a href="#DataStream-→-KeyedStream" class="headerlink" title="DataStream → KeyedStream #"></a>DataStream → KeyedStream <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/datastream/operators/overview/#datastream-rarr-keyedstream">#</a></h4><p>​		Logically partitions a stream into disjoint partitions. All records with the same key are assigned to the same partition. Internally, <em>keyBy()</em> is implemented with hash partitioning</p>
<p>​		将数据流逻辑上划分到不同的分区中，具有相同key的记录会被分配到同一个分区中，使用的是hash分区算法对记录分区，因此相同hash值的记录会被分配到同一个分区(记录本身可能不同)。</p>
<p>​		<img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211107182703069.png" alt="image-20211107182703069"></p>
<h3 id="3-5-max与maxBy"><a href="#3-5-max与maxBy" class="headerlink" title="3.5 max与maxBy"></a>3.5 max与maxBy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformTest2_RollingAggregation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文本文件中读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;SensorReading&gt; mapedStream = dataStream.map(new MapFunction&lt;String, SensorReading&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public SensorReading map(String value) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//                String[] fields = value.split(&quot;,&quot;);</span></span><br><span class="line"><span class="comment">//                return new SensorReading(fields[0], Long.valueOf(fields[1]), Double.valueOf(fields[2]));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式简化</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; mapedStream = dataStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据stream中sensorReading对象的id字段来分区</span></span><br><span class="line">        KeyedStream&lt;SensorReading, Tuple&gt; keyedStream = mapedStream.keyBy(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keyBy的另一种方式，</span></span><br><span class="line">        <span class="comment">// SensorReading::getId是jdk8中的方法引用的使用，表示获取对象类型中的方法</span></span><br><span class="line">        <span class="comment">// KeyedStream&lt;SensorReading, String&gt; keyedStream1 = mapedStream.keyBy(SensorReading::getId);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动聚合</span></span><br><span class="line">        <span class="comment">// 仅仅指定key的最大值覆盖对象中原值，结果不是当前的对象</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; singleOutputStream = keyedStream.max(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取指定key值最大的对象信息</span></span><br><span class="line">        <span class="comment">// SingleOutputStreamOperator&lt;SensorReading&gt; singleOutputStream = keyedStream.maxBy(&quot;temperature&quot;);</span></span><br><span class="line">        <span class="comment">// 多实验体会max与maxBy的区别</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印到控制台</span></span><br><span class="line">        singleOutputStream.print(<span class="string">&quot;max&quot;</span>);</span><br><span class="line">        <span class="comment">// 程序执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-reduce"><a href="#3-6-reduce" class="headerlink" title="3.6 reduce"></a>3.6 reduce</h3><h4 id="KeyedStream-→-DataStream"><a href="#KeyedStream-→-DataStream" class="headerlink" title="KeyedStream → DataStream #"></a>KeyedStream → DataStream <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/datastream/operators/overview/#keyedstream-rarr-datastream">#</a></h4><p>​			A “rolling” reduce on a keyed data stream. Combines the current element with the last reduced value and emits the new value.</p>
<p>​			将当前记录数据与上一次规约的结果再次规约后输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformTest3_Reduce</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文本文件中读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式简化</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; mapedStream = dataStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据stream中sensorReading对象的id字段来分区</span></span><br><span class="line">        KeyedStream&lt;SensorReading, Tuple&gt; keyedStream = mapedStream.keyBy(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reduce操作，获取temperature的（历史）最大值，以及当前的时间戳</span></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;SensorReading&gt; reduceResult = </span></span><br><span class="line"><span class="comment">//        keyedStream.reduce(new ReduceFunction&lt;SensorReading&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public SensorReading reduce(SensorReading value1, SensorReading value2) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//                return new SensorReading(</span></span><br><span class="line"><span class="comment">//                        value1.getId(),</span></span><br><span class="line"><span class="comment">//                        value2.getTimestamp(),</span></span><br><span class="line"><span class="comment">//                        Math.max(value1.getTemperature(), value2.getTemperature())</span></span><br><span class="line"><span class="comment">//                );</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="comment">// lambda表达式写法</span></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; reduceResult = </span><br><span class="line">            keyedStream.reduce((curState, newData) -&gt;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SensorReading</span>(</span><br><span class="line">                        curState.getId(),</span><br><span class="line">                        newData.getTimestamp(),</span><br><span class="line">                        Math.max(curState.getTemperature(), newData.getTemperature())));</span><br><span class="line">        reduceResult.print();</span><br><span class="line">        <span class="comment">// 程序执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-Split与Select"><a href="#3-7-Split与Select" class="headerlink" title="3.7 Split与Select"></a>3.7 Split与Select</h3><p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211107181237261.png" alt="image-20211107181237261"></p>
<p>**DataStream—-&gt;SplitStream **  根据某些特征将一个DataStream切分成两个或多个DataStream.</p>
<p>​		</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211107183043268.png" alt="image-20211107183043268"></p>
<p><strong>SplitStream—-&gt;DataStream</strong> 从一个SplitStream中获取一个或多个DataStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformTest4_MultipleStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从文本文件中读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; dataStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; sensorReadingStream = dataStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用split标记切分流数据</span></span><br><span class="line">        SplitStream&lt;SensorReading&gt; splitStream = sensorReadingStream.split(<span class="keyword">new</span> <span class="title class_">OutputSelector</span>&lt;SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">select</span><span class="params">(SensorReading value)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> value.getTemperature() &gt; <span class="number">35</span> ? Collections.singleton(<span class="string">&quot;high&quot;</span>):Collections.singleton(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用select筛选</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; highStream = splitStream.select(<span class="string">&quot;high&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; lowStream = splitStream.select(<span class="string">&quot;low&quot;</span>);</span><br><span class="line">        DataStream&lt;SensorReading&gt; allStream = splitStream.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印到控制台</span></span><br><span class="line">        highStream.print(<span class="string">&quot;high&quot;</span>); <span class="comment">// 打印标记为“high”的数据</span></span><br><span class="line">        lowStream.print(<span class="string">&quot;low&quot;</span>); <span class="comment">// 打印标记为&quot;low&quot;的数据</span></span><br><span class="line">        allStream.print(<span class="string">&quot;all&quot;</span>); <span class="comment">// 打印标记为&quot;high&quot;和&quot;low&quot;的数据</span></span><br><span class="line">        <span class="comment">// 程序执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-8-Connect和CoMap"><a href="#3-8-Connect和CoMap" class="headerlink" title="3.8 Connect和CoMap"></a>3.8 Connect和CoMap</h3><h4 id="DataStream-DataStream-→-ConnectedStream"><a href="#DataStream-DataStream-→-ConnectedStream" class="headerlink" title="DataStream,DataStream → ConnectedStream #"></a>DataStream,DataStream → ConnectedStream <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/datastream/operators/overview/#datastreamdatastream-rarr-connectedstream">#</a></h4><p>“Connects” two data streams retaining their types. Connect allowing for shared state between the two streams.</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211107230133974.png" alt="image-20211107230133974"></p>
<p><strong>DataStream,DataStream—-&gt;ConnectedStream</strong> 两个stream被connect，只是把它们放到同一个篮子中，内部依然保持各自的数据和形式上不发生变化，两个流相互独立。connect操作中的两条流的状态可以共享。</p>
<h4 id="ConnectedStream-→-DataStream"><a href="#ConnectedStream-→-DataStream" class="headerlink" title="ConnectedStream → DataStream #"></a>ConnectedStream → DataStream <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/datastream/operators/overview/#connectedstream-rarr-datastream">#</a></h4><p>Similar to map and flatMap on a connected data stream</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211107232313476.png" alt="image-20211107232313476"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合流 connect</span></span><br><span class="line"><span class="comment">// 测试两种不同类型的数据流合并</span></span><br><span class="line"><span class="comment">// 1. 将high流转换成二元组类型，与low流连接合并，输出信息</span></span><br><span class="line">SingleOutputStreamOperator&lt;Tuple2&lt;String, Double&gt;&gt; highTempStream = highStream.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;SensorReading, Tuple2&lt;String, Double&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;String, Double&gt; <span class="title function_">map</span><span class="params">(SensorReading value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(value.getId(), value.getTemperature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2. 使用connect算子合并</span></span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;String, Double&gt;, SensorReading&gt; connectedStreams = highTempStream.connect(lowStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 合并两条流， connectedStream的map是分别对其中的stream执行map方法</span></span><br><span class="line">SingleOutputStreamOperator&lt;Object&gt; resultStream = connectedStreams.map(<span class="keyword">new</span> <span class="title class_">CoMapFunction</span>&lt;Tuple2&lt;String, Double&gt;, SensorReading, Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">map1</span><span class="params">(Tuple2&lt;String, Double&gt; value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple3</span>&lt;String, Double, String&gt;(value.f0, value.f1, <span class="string">&quot;high temp warning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">map2</span><span class="params">(SensorReading value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(value.getId(), <span class="string">&quot;normal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">resultStream.print();</span><br></pre></td></tr></table></figure>



<h3 id="3-9-Union"><a href="#3-9-Union" class="headerlink" title="3.9 Union"></a>3.9 Union</h3><h4 id="DataStream-→-DataStream"><a href="#DataStream-→-DataStream" class="headerlink" title="DataStream* → DataStream #"></a>DataStream* → DataStream <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/datastream/operators/overview/#datastream-rarr-datastream-3">#</a></h4><p>Union of two or more data streams creating a new stream containing all the elements from all the streams. Note: If you union a data stream with itself you will get each element twice in the resulting stream.</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211108005213438.png" alt="image-20211108005213438"></p>
<p>Union操作的多个流必须是相同的数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union 合并相同类型的多条流</span></span><br><span class="line">DataStream&lt;SensorReading&gt; unionStream = lowStream.union(allStream);</span><br><span class="line">unionStream.print(<span class="string">&quot;union&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-10-实现UDF函数–更细粒度的控制流"><a href="#3-10-实现UDF函数–更细粒度的控制流" class="headerlink" title="3.10 实现UDF函数–更细粒度的控制流"></a>3.10 实现UDF函数–更细粒度的控制流</h3><h4 id="1-函数类（Function-Classes）"><a href="#1-函数类（Function-Classes）" class="headerlink" title="1. 函数类（Function Classes）"></a>1. 函数类（Function Classes）</h4><p>​		Flink中暴露了所有的udf函数的接口（实现方式为接口或抽象类）。例如MapFunction,FilterFunction,ProcessFunction等等。</p>
<p>​		例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMapFunction</span> <span class="keyword">implements</span> <span class="title class_">MapFunction</span>&lt;String, Integer&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">map</span><span class="params">(String value)</span> &#123; <span class="keyword">return</span> Integer.parseInt(value); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">data.map(<span class="keyword">new</span> <span class="title class_">MyMapFunction</span>());</span><br></pre></td></tr></table></figure>

<h4 id="2-匿名函数（Lambda-Functions）"><a href="#2-匿名函数（Lambda-Functions）" class="headerlink" title="2.匿名函数（Lambda Functions）"></a>2.匿名函数（Lambda Functions）</h4><p>​		例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Integer&gt; () &#123;</span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">map</span><span class="params">(String value)</span> &#123; <span class="keyword">return</span> Integer.parseInt(value); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;SensorReading&gt; reduceResult = keyedStream.reduce((curState, newData) -&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SensorReading</span>(</span><br><span class="line">                curState.getId(),</span><br><span class="line">                newData.getTimestamp(),</span><br><span class="line">                Math.max(curState.getTemperature(), newData.getTemperature())));</span><br></pre></td></tr></table></figure>

<h4 id="3-富函数（Rich-Functions）"><a href="#3-富函数（Rich-Functions）" class="headerlink" title="3.富函数（Rich Functions）"></a>3.富函数（Rich Functions）</h4><p>​		Rich functions provide, in addition to the user-defined function (map, reduce, etc), four methods: <code>open</code>, <code>close</code>, <code>getRuntimeContext</code>, and <code>setRuntimeContext</code>. These are useful for parameterizing the function (see <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/dataset/overview/#passing-parameters-to-functions">Passing Parameters to Functions</a>), creating and finalizing local state, accessing broadcast variables (see <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/dataset/overview/#broadcast-variables">Broadcast Variables</a>), and for accessing runtime information such as accumulators and counters (see <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/datastream/user_defined_functions/#accumulators--counters">Accumulators and Counters</a>), and information on iterations (see <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/dataset/iterations/">Iterations</a>).</p>
<p>​		所有的Flink函数类都有Rich版本，它与常规函数的不同点在于，可以获取运行环境的上下文，并拥有一些生命周期的方法，所以可以实现一些复杂的功能。</p>
<p>典型的生命周期方法:</p>
<ul>
<li>open() 方法是RichFunction的初始方法，在一个的算子例如map或filter被调用之前open()方法就会被调用。</li>
<li>close() 方法是生命周期中最后被调用的方法，做一些清理工作。</li>
<li>getRuntimeContext()方法提供了RuntimeContext的一些信息，例如函数执行的并行度，任务名字，以及state状态</li>
<li>。。。</li>
</ul>
<p>向转换算子中传递参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DataSet&lt;Integer&gt; toFilter = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">config.setInteger(<span class="string">&quot;limit&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">toFilter.filter(<span class="keyword">new</span> <span class="title class_">RichFilterFunction</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      limit = parameters.getInteger(<span class="string">&quot;limit&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">return</span> value &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).withParameters(config);</span><br></pre></td></tr></table></figure>



<h2 id="4-Sink"><a href="#4-Sink" class="headerlink" title="4. Sink"></a>4. Sink</h2><h3 id="4-1-sink-kafka"><a href="#4-1-sink-kafka" class="headerlink" title="4.1 sink kafka"></a>4.1 sink kafka</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinkTest1_Kafka</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 从文本文件中读取数据</span></span><br><span class="line"><span class="comment">//        DataStreamSource&lt;String&gt; inputStream = env.readTextFile(&quot;src/main/resources/sensor.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// kafka消费配置</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>,<span class="string">&quot;linux111:9092&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;group.id&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;key.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;auto.offset.reset&quot;</span>,<span class="string">&quot;latest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置kafka connector，消费数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.addSource(<span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;String&gt;(<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), properties));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; dataStream = inputStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>])).toString();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出到kafka</span></span><br><span class="line">        dataStream.addSink(<span class="keyword">new</span> <span class="title class_">FlinkKafkaProducer</span>&lt;String&gt;(<span class="string">&quot;linux111:9092,linux112:9092&quot;</span>, <span class="string">&quot;flinktest&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-sink-Redis"><a href="#4-2-sink-Redis" class="headerlink" title="4.2 sink Redis"></a>4.2 sink Redis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinkTest2_Redis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 从文本文件中读取数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; dataStream = inputStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置redis的连接配置</span></span><br><span class="line">        <span class="type">FlinkJedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlinkJedisPoolConfig</span>.Builder()</span><br><span class="line">                .setHost(<span class="string">&quot;linux111&quot;</span>)</span><br><span class="line">                .setPort(<span class="number">6379</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 将RedisSink添加进流</span></span><br><span class="line">        dataStream.addSink(<span class="keyword">new</span> <span class="title class_">RedisSink</span>&lt;&gt;(config, <span class="keyword">new</span> <span class="title class_">MyRedisMapper</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyRedisMapper</span> <span class="keyword">implements</span> <span class="title class_">RedisMapper</span>&lt;SensorReading&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> RedisCommandDescription <span class="title function_">getCommandDescription</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// redis的命令操作， 使用hset 将数据存入&quot;sensor_temp&quot;表中，key为id, value为temperature</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCommandDescription</span>(RedisCommand.HSET, <span class="string">&quot;sensor_temp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getKeyFromData</span><span class="params">(SensorReading sensorReading)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sensorReading.getId();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getValueFromData</span><span class="params">(SensorReading sensorReading)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sensorReading.getTemperature().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="窗口–Window-API"><a href="#窗口–Window-API" class="headerlink" title="窗口–Window API"></a>窗口–Window API</h1><p>Aggregating events (e.g., counts, sums) works differently on streams than in batch processing. For example, it is impossible to count all elements in a stream, because streams are in general infinite (unbounded). Instead, aggregates on streams (counts, sums, etc), are scoped by <strong>windows</strong>, such as <em>“count over the last 5 minutes”</em>, or <em>“sum of the last 100 elements”</em>.</p>
<p>Windows can be <em>time driven</em> (example: every 30 seconds) or <em>data driven</em> (example: every 100 elements). One typically distinguishes different types of windows, such as <em>tumbling windows</em> (no overlap), <em>sliding windows</em> (with overlap), and <em>session windows</em> (punctuated by a gap of inactivity).</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211108170754108.png" alt="image-20211108170754108"></p>
<p>Please check out this <a target="_blank" rel="noopener" href="https://flink.apache.org/news/2015/12/04/Introducing-windows.html">blog post</a> for additional examples of windows or take a look a <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/">window documentation</a> of the DataStream API.</p>
<p>​		在无限的数据流上做聚合操作时，引入窗口的概念。可以设定一段时间对接收到的数据做聚合操作，也可以通过判断接受的数据量来决定是否开始聚合操作，在flink中这两种对数据的聚合操作分别称为: <strong>时间驱动</strong>和<strong>数据驱动</strong></p>
<p>参考链接: <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/">https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/</a></p>
<h2 id="窗口类型"><a href="#窗口类型" class="headerlink" title="窗口类型"></a>窗口类型</h2><ul>
<li><p>时间窗口（Time Window）</p>
<ul>
<li>滚动时间窗口 （Tumbling Windows）</li>
<li>滑动时间窗口（Sliding Windows）</li>
<li>会话窗口（Session Windows）</li>
</ul>
</li>
<li><p>计数窗口（Count Window）</p>
<ul>
<li>滚动计数窗口</li>
<li>滑动计数窗口</li>
</ul>
</li>
</ul>
<h2 id="窗口的生命周期"><a href="#窗口的生命周期" class="headerlink" title="窗口的生命周期"></a>窗口的生命周期</h2><pre><code>      In a nutshell, a window is **created** as soon as the first element that should belong to this window arrives, and the window is **completely removed** when the time (event or processing time) passes its end timestamp plus the user-specified `allowed lateness` (see [Allowed Lateness](https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#allowed-lateness)). Flink guarantees removal only for time-based windows and not for other types, *e.g.* global windows (see [Window Assigners](https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#window-assigners)). For example, with an event-time-based windowing strategy that creates non-overlapping (or tumbling) windows every 5 minutes and has an allowed lateness of 1 min, Flink will create a new window for the interval between `12:00` and `12:05` when the first element with a timestamp that falls into this interval arrives, and it will remove it when the watermark passes the `12:06` timestamp.
</code></pre>
<p>​		当第一个元素传递过来时，窗口就被创建了，flink会在指定的时间窗口内对窗口内的数据进行计算，当到达窗口结束时间时，窗口就会被移除。</p>
<p>In addition, each window will have a <code>Trigger</code> (see <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#triggers">Triggers</a>) and a function (<code>ProcessWindowFunction</code>, <code>ReduceFunction</code>, or <code>AggregateFunction</code>) (see <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#window-functions">Window Functions</a>) attached to it. The function will contain the computation to be applied to the contents of the window, while the <code>Trigger</code> specifies the conditions under which the window is considered ready for the function to be applied. A triggering policy might be something like “when the number of elements in the window is more than 4”, or “when the watermark passes the end of the window”. A trigger can also decide to purge a window’s contents any time between its creation and removal. Purging in this case only refers to the elements in the window, and <em>not</em> the window metadata. This means that new data can still be added to that window.</p>
<p>​		每个窗口都会有一个触发器(Trigger)和计算函数(ProcessWindowFunction,ReduceFunction，AggregateFunction).</p>
<p>Apart from the above, you can specify an <code>Evictor</code> (see <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#evictors">Evictors</a>) which will be able to remove elements from the window after the trigger fires and before and&#x2F;or after the function is applied.</p>
<p>​		除了上面的触发器和函数，也可以使用Evictor方法来移除窗口中的元素, 例如带两个参数的countWindow方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Windows this &#123;<span class="doctag">@code</span> KeyedStream&#125; into sliding count windows.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size The size of the windows in number of elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slide The slide interval in number of elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title function_">countWindow</span><span class="params">(<span class="type">long</span> size, <span class="type">long</span> slide)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> window(GlobalWindows.create())</span><br><span class="line">			.evictor(CountEvictor.of(size))</span><br><span class="line">			.trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the following we go into more detail for each of the components above. We start with the required parts in the above snippet (see <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#keyed-vs-non-keyed-windows">Keyed vs Non-Keyed Windows</a>, <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#window-assigner">Window Assigner</a>, and <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#window-function">Window Function</a>) before moving to the optional ones.</p>
<h2 id="窗口分配器-Window-Assigner"><a href="#窗口分配器-Window-Assigner" class="headerlink" title="窗口分配器  Window Assigner"></a>窗口分配器  Window Assigner</h2><p>​		使用window()方法来定义一个窗口，然后基于这个窗口做一些聚合或其他操作。window()方法必须在keyBy之后才可以使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Windows this data stream to a &#123;<span class="doctag">@code</span> WindowedStream&#125;, which evaluates windows</span></span><br><span class="line"><span class="comment"> * over a key grouped stream. Elements are put into windows by a &#123;<span class="doctag">@link</span> WindowAssigner&#125;. The</span></span><br><span class="line"><span class="comment"> * grouping of elements is done both by key and by window.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.windowing.triggers.Trigger&#125; can be defined to</span></span><br><span class="line"><span class="comment"> * specify when windows are evaluated. However, &#123;<span class="doctag">@code</span> WindowAssigners&#125; have a default</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Trigger&#125; that is used if a &#123;<span class="doctag">@code</span> Trigger&#125; is not specified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> assigner The &#123;<span class="doctag">@code</span> WindowAssigner&#125; that assigns elements to windows.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The trigger windows data stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> &lt;W <span class="keyword">extends</span> <span class="title class_">Window</span>&gt; WindowedStream&lt;T, KEY, W&gt; <span class="title function_">window</span><span class="params">(WindowAssigner&lt;? <span class="built_in">super</span> T, W&gt; assigner)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowedStream</span>&lt;&gt;(<span class="built_in">this</span>, assigner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>窗口分配器WindowAssigner类负责将经过keyBy的数据分配到每个窗口中，分配器提供了触发器（Trigger）给WindowedStream，当满足窗口触发的条件时，就会触发定义在窗口上的操作开始执行。</p>
<p>例如滚动窗口分配器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TumblingEventTimeWindows</span> <span class="keyword">extends</span> <span class="title class_">WindowAssigner</span>&lt;Object, TimeWindow&gt;&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title function_">assignWindows</span><span class="params">(Object element, <span class="type">long</span> timestamp, WindowAssignerContext context)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">			<span class="comment">// Long.MIN_VALUE is currently assigned when no timestamp is present</span></span><br><span class="line">			<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> TimeWindow.getWindowStartWithOffset(timestamp, offset, size);</span><br><span class="line">			<span class="keyword">return</span> Collections.singletonList(<span class="keyword">new</span> <span class="title class_">TimeWindow</span>(start, start + size));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Record has Long.MIN_VALUE timestamp (= no timestamp marker). &quot;</span> +</span><br><span class="line">					<span class="string">&quot;Is the time characteristic set to &#x27;ProcessingTime&#x27;, or did you forget to call &quot;</span> +</span><br><span class="line">					<span class="string">&quot;&#x27;DataStream.assignTimestampsAndWatermarks(...)&#x27;?&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法assignWindows()负责划分窗口的起始和结束时间点，</p>
<p>在TimeWindow类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeWindow</span> <span class="keyword">extends</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getWindowStartWithOffset</span><span class="params">(<span class="type">long</span> timestamp, <span class="type">long</span> offset, <span class="type">long</span> windowSize)</span> &#123;</span><br><span class="line">   		<span class="keyword">return</span> timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到具体实现分窗的细节，上述代码中getWindowStartWithOffset方法返回了窗口的开始位置，即窗口大小的整数倍。</p>
<p>在window()方法中可以指定使用的窗口分配器，在flink中已定义好的窗口分配器包括: </p>
<p>滚动窗口(<em>tumbling windows</em>)</p>
<p>滑动窗口( <em>sliding windows</em>),</p>
<p>会话窗口( <em>session windows</em>) </p>
<p>全局窗口( <em>global windows</em>)</p>
<p><strong>滚动窗口 Tumbling Windows</strong></p>
<p>A <em>tumbling windows</em> assigner assigns each element to a window of a specified <em>window size</em>. Tumbling windows have a fixed size and do not overlap. For example, if you specify a tumbling window with a size of 5 minutes, the current window will be evaluated and a new window will be started every five minutes as illustrated by the following figure.</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/tumbling-windows.svg" alt="Tumbling Windows"></p>
<p>数据按照固定的窗口长度对数据切分</p>
<p>时间对齐，窗口长度固定，没有重叠</p>
<p>使用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tumbling event-time windows</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tumbling processing-time windows</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// daily tumbling event-time windows offset by -8 hours.</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Time.days(<span class="number">1</span>), Time.hours(-<span class="number">8</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>





<p><strong>滑动窗口 Sliding Windows</strong></p>
<p>The <em>sliding windows</em> assigner assigns elements to windows of fixed length. Similar to a tumbling windows assigner, the size of the windows is configured by the <em>window size</em> parameter. An additional <em>window slide</em> parameter controls how frequently a sliding window is started. Hence, sliding windows can be overlapping if the slide is smaller than the window size. In this case elements are assigned to multiple windows.</p>
<p>For example, you could have windows of size 10 minutes that slides by 5 minutes. With this you get every 5 minutes a window that contains the events that arrived during the last 10 minutes as depicted by the following figure.</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/sliding-windows.svg" alt="sliding windows"></p>
<p>滑动窗口是固定窗口更广泛的一种形式，滑动窗口有固定窗口和滑动间隔组成</p>
<p>窗口的长度固定，数据可以有重叠</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliding event-time windows</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliding processing-time windows</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliding processing-time windows offset by -8 hours</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingProcessingTimeWindows.of(Time.hours(<span class="number">12</span>), Time.hours(<span class="number">1</span>), Time.hours(-<span class="number">8</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>



<p><strong>会话窗口 Session Windows</strong></p>
<p>The <em>session windows</em> assigner groups elements by sessions of activity. Session windows do not overlap and do not have a fixed start and end time, in contrast to <em>tumbling windows</em> and <em>sliding windows</em>. Instead a session window closes when it does not receive elements for a certain period of time, <em>i.e.</em>, when a gap of inactivity occurred. A session window assigner can be configured with either a static <em>session gap</em> or with a <em>session gap extractor</em> function which defines how long the period of inactivity is. When this period expires, the current session closes and subsequent elements are assigned to a new session window.</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/session-windows.svg" alt="session windows"></p>
<p>当超时仍未接收到消息时，会话窗口关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// event-time session windows with static gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(EventTimeSessionWindows.withGap(Time.minutes(<span class="number">10</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// event-time session windows with dynamic gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(EventTimeSessionWindows.withDynamicGap((element) -&gt; &#123;</span><br><span class="line">        <span class="comment">// determine and return session gap</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// processing-time session windows with static gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(ProcessingTimeSessionWindows.withGap(Time.minutes(<span class="number">10</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// processing-time session windows with dynamic gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(ProcessingTimeSessionWindows.withDynamicGap((element) -&gt; &#123;</span><br><span class="line">        <span class="comment">// determine and return session gap</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>



<h3 id="全局窗口-Global-Windows"><a href="#全局窗口-Global-Windows" class="headerlink" title="全局窗口 Global Windows #"></a>全局窗口 Global Windows <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#global-windows">#</a></h3><p>A <em>global windows</em> assigner assigns all elements with the same key to the same single <em>global window</em>. This windowing scheme is only useful if you also specify a custom <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/operators/windows/#triggers">trigger</a>. Otherwise, no computation will be performed, as the global window does not have a natural end at which we could process the aggregated elements.</p>
<p>​		全局窗口就是会收集所有的数据，使用全局窗口时，需要有用户定义好计算执行的触发器，否则全局窗口是不会做任何操作。</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/non-windowed.svg" alt="global windows"></p>
<h2 id="窗口函数-Window-Function"><a href="#窗口函数-Window-Function" class="headerlink" title="窗口函数 Window Function"></a>窗口函数 Window Function</h2><ol>
<li><p>增来窗口聚合函数</p>
<p> ​	每来一条数据就进行处理，保持一个简单的状态</p>
<p> 例如: ReduceFunction，AggregatationFunction</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 增量聚合</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; resultStream = dataStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"><span class="comment">//                .countWindow(1000);  // 计数窗口</span></span><br><span class="line"><span class="comment">//                .timeWindow(Time.seconds(10))  // 时间窗口</span></span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">10</span>))</span><br><span class="line">                .aggregate(<span class="keyword">new</span> <span class="title class_">AggregateFunction</span>&lt;SensorReading, Integer, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">                               <span class="comment">// 统计时间窗口中的记录个数，每来一条数据就做一次累加</span></span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 简单记录key的id， 这里由于分区的字段只有一个，因此可以单独用变量记录，如果是按照多个字段分组的话，就会有多个记录的key</span></span><br><span class="line">                               <span class="keyword">private</span> String keyId;</span><br><span class="line"></span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="keyword">public</span> Integer <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">                                   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">(SensorReading value, Integer accumulator)</span> &#123;</span><br><span class="line">                                   keyId = value.getId();</span><br><span class="line">                                   <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title function_">getResult</span><span class="params">(Integer accumulator)</span> &#123;</span><br><span class="line">                                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(keyId, accumulator);</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               <span class="meta">@Override</span></span><br><span class="line">                               <span class="keyword">public</span> Integer <span class="title function_">merge</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                                   <span class="keyword">return</span> a + b;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        resultStream.print(<span class="string">&quot;result&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>​	2.全量窗口聚合函数</p>
<p>​			先把窗口所有数据收集起来，等到计算的时候再遍历处理所有数据</p>
<p>​		例如: ProcessWindowFunction， WindowFunction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Long, Integer&gt;&gt; resultStream2 = dataStream.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">10</span>))</span><br><span class="line"><span class="comment">//                .process(new ProcessWindowFunction&lt;SensorReading, Object, Tuple, TimeWindow&gt;() &#123;</span></span><br><span class="line"><span class="comment">//                    @Override</span></span><br><span class="line"><span class="comment">//                    public void process(Tuple tuple, Context context, Iterable&lt;SensorReading&gt; elements, Collector&lt;Object&gt; out) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;)</span></span><br><span class="line">                <span class="comment">// apply方法处理窗口里的所有数据，需要等窗口中的数据都到达或窗口结束时统一处理</span></span><br><span class="line">                <span class="comment">// 使用这种全局函数，能够获取的信息更多，使用上更加灵活些</span></span><br><span class="line">                .apply(<span class="keyword">new</span> <span class="title class_">WindowFunction</span>&lt;SensorReading, Tuple3&lt;String, Long, Integer&gt;, Tuple, TimeWindow&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Tuple tuple, TimeWindow window, Iterable&lt;SensorReading&gt; input, Collector&lt;Tuple3&lt;String, Long, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 计算每个key对应的数据在当前窗口中的个数</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> tuple.getField(<span class="number">0</span>);</span><br><span class="line">                        <span class="type">long</span> <span class="variable">windowEnd</span> <span class="operator">=</span> window.getEnd();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> IteratorUtils.toList(input.iterator()).size();</span><br><span class="line">                        out.collect(<span class="keyword">new</span> <span class="title class_">Tuple3</span>&lt;&gt;(id, windowEnd, count));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        resultStream2.print(<span class="string">&quot;result2&quot;</span>);</span><br></pre></td></tr></table></figure>





<h1 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h1><ul>
<li>Event Time 事件创发生的时间</li>
<li>Ingestion Time 数据进入Flink的时间</li>
<li>Process Time 数据被Flink处理的时间，执行操作算子的时间，与机器系统的时间有关</li>
</ul>
<p>下面两段官方文档对处理时间(ProcessTime)和事件时间(EventTime)的说明</p>
<ul>
<li><p><strong>Processing time:</strong> Processing time refers to the system time of the machine that is executing the respective operation.</p>
<p>  程序各自执行处理操作时，本地机器的时间。</p>
<p>  When a streaming program runs on processing time, all time-based operations (like time windows) will use the system clock of the machines that run the respective operator. An hourly processing time window will include all records that arrived at a specific operator between the times when the system clock indicated the full hour. For example, if an application begins running at 9:15am, the first hourly processing time window will include events processed between 9:15am and 10:00am, the next window will include events processed between 10:00am and 11:00am, and so on.</p>
<p>  ProcessTime模式下，流处理程序所有基于时间的操作都是基于机器的时间系统来各自运行的，例如当设定时每小时的时间窗口，那么执行的时间会在每个整点时刻执行，当前一个小时内的所有数据，以此类推。</p>
<p>  Processing time is the simplest notion of time and requires no coordination between streams and machines. It provides the best performance and the lowest latency. However, in distributed and asynchronous environments processing time does not provide determinism, because it is susceptible to the speed at which records arrive in the system (for example from the message queue), to the speed at which the records flow between operators inside the system, and to outages (scheduled, or otherwise).</p>
<p>  在单机环境下使用ProcessTime模式是最简单的，但在分布式异步的处理环境中，由于数据到达每台机器的速率不同等原因(尤其是当数据是经过了消息队列收集)，是的数据处理的结果不准确。</p>
</li>
<li><p><strong>Event time:</strong> Event time is the time that each individual event occurred on its producing device. </p>
<p>  This time is typically embedded within the records before they enter Flink, and that <em>event timestamp</em> can be extracted from each record. In event time, the progress of time depends on the data, not on any wall clocks. Event time programs must specify how to generate <em>Event Time Watermarks</em>, which is the mechanism that signals progress in event time. This watermarking mechanism is described in a later section, <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/concepts/time/#event-time-and-watermarks">below</a>.</p>
<p>  依据数据中事件发生的时间来划分流处理的时间窗口，这样就不会因为程序所在的机器时间不同步等原因导致处理结果不准确。</p>
<p>  In a perfect world, event time processing would yield completely consistent and deterministic results, regardless of when events arrive, or their ordering. However, unless the events are known to arrive in-order (by timestamp), event time processing incurs some latency while waiting for out-of-order events. As it is only possible to wait for a finite period of time, this places a limit on how deterministic event time applications can be.</p>
</li>
</ul>
<h2 id="事件时间模式"><a href="#事件时间模式" class="headerlink" title="事件时间模式"></a>事件时间模式</h2><p>​		要使用事件时间的模式，需要先指定时间特性为事件时间，可以如下设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 指定使用EventTime模式, 当前使用的版本(1.11)中默认为ProcessTime模式</span></span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime); </span><br></pre></td></tr></table></figure>

<p>​		要使用EventTime模式，就需要知道流中的时间是基于那些信息的来，不同于ProcessTime的时间来自于程序执行时的系统时间，EventTime使用的时间需要有用户自己指定，在Flink中提供了<strong>TimeAssigner</strong>接口及其实现类从接收到的数据中获得EventTime。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        DataStreamSource&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line">      </span><br><span class="line">		SingleOutputStreamOperator&lt;SensorReading&gt; dataStream = inputStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;)</span><br><span class="line">                <span class="comment">// 升序数据设置时间戳与水印</span></span><br><span class="line"><span class="comment">//                .assignTimestampsAndWatermarks(new AscendingTimestampExtractor&lt;SensorReading&gt;() &#123;</span></span><br><span class="line"><span class="comment">//                    @Override</span></span><br><span class="line"><span class="comment">//                    public long extractAscendingTimestamp(SensorReading element) &#123;</span></span><br><span class="line"><span class="comment">//                        return element.getTimestamp()*1000L;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;)</span></span><br><span class="line">                <span class="comment">// 乱序数据设置时间戳与水印</span></span><br><span class="line">                .assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="title class_">BoundedOutOfOrdernessTimestampExtractor</span>&lt;SensorReading&gt;(Time.seconds(<span class="number">3</span>)) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">extractTimestamp</span><span class="params">(SensorReading element)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> element.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>BoundedOutOfOrdernessTimestampExtractor抽象类就是TimeAssigner的子类，上述代码中以匿名类的方式实现该抽象类，其中的extractTimestamp()方法指定了Event-Time的获取方式。</p>
<h2 id="水印，数据延迟"><a href="#水印，数据延迟" class="headerlink" title="水印，数据延迟"></a>水印，数据延迟</h2><h3 id="水印（-WaterMark）"><a href="#水印（-WaterMark）" class="headerlink" title="水印（ WaterMark）"></a>水印（ WaterMark）</h3><p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211118002519387.png" alt="image-20211118002519387"></p>
<p>​		从这段话中可以看到，所谓水印就是针对流中 延迟达到的数据，</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/stream_watermark_in_order.svg" alt="A data stream with events (in order) and watermarks"></p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/stream_watermark_out_of_order.svg" alt="A data stream with events (out of order) and watermarks"></p>
<p>在乱序的数据流中注入水印数据，我们认为当读取到的水印数据时间为一个时间窗口的最后时刻时，则认为小于这个水印时间的数据都已经接收到窗口中，这时就会触发窗口计算执行。</p>
<p>​		上述代码中使用assignTimestampsAndWatermarks这个算子除了指定EventTime的取值，同时也指定了水印数据的生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">BoundedOutOfOrdernessTimestampExtractor</span>&lt;SensorReading&gt;(Time.seconds(<span class="number">3</span>)) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">extractTimestamp</span><span class="params">(SensorReading element)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> element.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The (fixed) interval between the maximum seen timestamp seen in the records</span></span><br><span class="line"><span class="comment"> * and that of the watermark to be emitted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> maxOutOfOrderness;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BoundedOutOfOrdernessTimestampExtractor</span><span class="params">(Time maxOutOfOrderness)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (maxOutOfOrderness.toMilliseconds() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Tried to set the maximum allowed &quot;</span> +</span><br><span class="line">         <span class="string">&quot;lateness to &quot;</span> + maxOutOfOrderness + <span class="string">&quot;. This parameter cannot be negative.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">this</span>.maxOutOfOrderness = maxOutOfOrderness.toMilliseconds();</span><br><span class="line">   <span class="built_in">this</span>.currentMaxTimestamp = Long.MIN_VALUE + <span class="built_in">this</span>.maxOutOfOrderness;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Watermark <span class="title function_">getCurrentWatermark</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// this guarantees that the watermark never goes backwards.</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">potentialWM</span> <span class="operator">=</span> currentMaxTimestamp - maxOutOfOrderness;</span><br><span class="line">		<span class="keyword">if</span> (potentialWM &gt;= lastEmittedWatermark) &#123;</span><br><span class="line">			lastEmittedWatermark = potentialWM;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Watermark</span>(lastEmittedWatermark);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造方法中的参数就是当前记录的时间戳与水印对象的时间间隔。</p>
<p>由该类中的getCurrentWaterMark方法可以知道事件时间与水印时间之间的关系</p>
<p>水印时间&#x3D;事件时间-允许的延迟时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line">    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);  <span class="comment">// 使用EventTime模式, 默认为ProcessTime模式</span></span><br><span class="line">    DataStreamSource&lt;String&gt; inputStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line">    SingleOutputStreamOperator&lt;SensorReading&gt; dataStream = inputStream.map(v -&gt; &#123;</span><br><span class="line">        String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">    &#125;)</span><br><span class="line">            <span class="comment">// 乱序数据设置时间戳与水印</span></span><br><span class="line">            .assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="title class_">BoundedOutOfOrdernessTimestampExtractor</span>&lt;SensorReading&gt;(Time.seconds(<span class="number">3</span>)) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">extractTimestamp</span><span class="params">(SensorReading element)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> element.getTimestamp() * <span class="number">1000L</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于事件时间的开窗测试</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计15秒内温度最小值</span></span><br><span class="line">    SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">            .timeWindow(Time.seconds(<span class="number">15</span>))  <span class="comment">// 创建滚动窗口</span></span><br><span class="line">            .minBy(<span class="string">&quot;temperature&quot;</span>);  <span class="comment">// 取窗口中最小值</span></span><br><span class="line"></span><br><span class="line">    minTempStream.print(<span class="string">&quot;minTemp&quot;</span>);</span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码样例中，采用事件时间的滚动窗口机制，窗口大小为15秒，乱序延迟为3秒。</p>
<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211118015453141.png" alt="image-20211118015453141"></p>
<p>这个测试中，当输入图中最后一条数据时，Flink程序输出了第一条结果，根据水印时间的计算方式可知</p>
<p>水印时间&#x3D;1636272738-3&#x3D;1636272735， 此时由于触发了窗口操作执行，因此可知当前的时间窗口大小为[1636272720,1636272735)</p>
<p>在该时间段之间的最小值的数据为 sensor_1,1636272732,28.9，而该条数据是在1636272737时刻之后到来的，可以看到这里使用水印的机制，就能避免错过正确的结果。</p>
<h2 id="处理延迟数据-Late-Data"><a href="#处理延迟数据-Late-Data" class="headerlink" title="处理延迟数据 Late Data"></a>处理延迟数据 Late Data</h2><p>​		水印机制在处理乱序达到的事件数据时，确实能够帮助程序执行时尽可能完整的接收到需要处理的数据，但是对于已经执行完而关闭的窗口来说， 在这之后到达的数据却无法再次被处理。</p>
<p>对于迟到的事件，有以下考虑:</p>
<ol>
<li>直接将迟到太久的数据丢弃；</li>
<li>迟到的数据重定向到另外的一条流中，Flink中的Side-Output-Data；</li>
<li>将迟到的数据与本应所属窗口的结果一起更新操作，这种情况需要保存计算完的窗口结果状态</li>
</ol>
<p>在Flink中针对EventTime模式的处理，默认会丢弃迟到的数据。</p>
<p>如果是需要将延迟的数据重定向到另外的流中，可以使用SideOutputLateData算子,如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">// 给迟到的数据指定一个标签</span></span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTagLate = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;SensorReading&gt;(<span class="string">&quot;late&quot;</span>)&#123;&#125;;</span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = dataStream.keyBy(SensorReading::getId)</span><br><span class="line">                .timeWindow(Time.seconds(<span class="number">15</span>))  <span class="comment">// 创建滚动窗口</span></span><br><span class="line">                .allowedLateness(Time.seconds(<span class="number">60</span>)) <span class="comment">// 设置允许延迟到达的时间阈值</span></span><br><span class="line">                .sideOutputLateData(outputTagLate) <span class="comment">// 将延迟到达的数据打上标签</span></span><br><span class="line">                .minBy(<span class="string">&quot;temperature&quot;</span>);  <span class="comment">// 取窗口中最小值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定标签上的数据</span></span><br><span class="line">        minTempStream.getSideOutput(outputTagLate)</span><br><span class="line"><span class="comment">//                .addSink(...)  // 可以sink到其他的位置存放</span></span><br><span class="line">                .print(<span class="string">&quot;late&quot;</span>);</span><br></pre></td></tr></table></figure>





<h1 id="流状态State"><a href="#流状态State" class="headerlink" title="流状态State"></a>流状态State</h1><p>​		什么是 state，流式计算的数据往往是转瞬即逝， 当然，真实业务场景不可能说所有的数据都是进来之后就走掉，没有任何东西留下来，那么留下来的东西其实就是称之为 state，中文可以翻译成状态。</p>
<p>参考文档: <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/fault-tolerance/state/">https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/datastream/fault-tolerance/state/</a></p>
<h2 id="Keyed-State"><a href="#Keyed-State" class="headerlink" title="Keyed State"></a>Keyed State</h2><p>​		使用Keyed State之前需要先给DataStream指定一个key，用来将流划分到不同的分区，在每个分区中都会有一个分区状态。</p>
<p>​		使用keyBy算子将DataStream转换成KeyedStream。</p>
<p>​		Flink中的KeyedStream数据模型并不是基于key-value的键值对，所以不需要用户来指定键值类型。在该模型中，keys是<em>虚拟的</em>，它们由实际数据上的分组算子来定义。</p>
<blockquote>
<p>The data model of Flink is not based on key-value pairs. Therefore, you do not need to physically pack the data set types into keys and values. Keys are “virtual”: they are defined as functions over the actual data to guide the grouping operator.</p>
</blockquote>
<p>keyBy方法的使用如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; dataStream = inputStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用key selector function来</span></span><br><span class="line">        KeyedStream&lt;SensorReading, String&gt; keyedStream = dataStream.keyBy(SensorReading::getId);</span><br><span class="line">        <span class="comment">// 使用旧版的keyBy(String... fields)算子返回的key类型就是个Tuple</span></span><br><span class="line"><span class="comment">//        KeyedStream&lt;SensorReading, Tuple&gt; keyedStream = dataStream.keyBy(&quot;id&quot;);</span></span><br></pre></td></tr></table></figure>





<ul>
<li><code>ValueState&lt;T&gt;</code>: This keeps a value that can be updated and retrieved (scoped to key of the input element as mentioned above, so there will possibly be one value for each key that the operation sees). The value can be set using <code>update(T)</code> and retrieved using <code>T value()</code>.</li>
<li><code>ListState&lt;T&gt;</code>: This keeps a list of elements. You can append elements and retrieve an <code>Iterable</code> over all currently stored elements. Elements are added using <code>add(T)</code> or <code>addAll(List&lt;T&gt;)</code>, the Iterable can be retrieved using <code>Iterable&lt;T&gt; get()</code>. You can also override the existing list with <code>update(List&lt;T&gt;)</code></li>
<li><code>ReducingState&lt;T&gt;</code>: This keeps a single value that represents the aggregation of all values added to the state. The  interface is similar to <code>ListState</code> but elements added using <code>add(T)</code> are reduced to an aggregate using a specified <code>ReduceFunction</code>.</li>
<li><code>AggregatingState&lt;IN, OUT&gt;</code>: This keeps a single value that represents the aggregation of all values added to the state. Contrary to <code>ReducingState</code>, the aggregate type may be different from the type of elements that are added to the state. The interface is the same as for <code>ListState</code> but elements added using <code>add(IN)</code> are aggregated using a specified <code>AggregateFunction</code>.</li>
<li><code>MapState&lt;UK, UV&gt;</code>: This keeps a list of mappings. You can put key-value pairs into the state and retrieve an <code>Iterable</code> over all currently stored mappings. Mappings are added using <code>put(UK, UV)</code> or <code>putAll(Map&lt;UK, UV&gt;)</code>. The value associated with a user key can be retrieved using <code>get(UK)</code>. The iterable views for mappings, keys and values can be retrieved using <code>entries()</code>, <code>keys()</code> and <code>values()</code> respectively. You can also use <code>isEmpty()</code> to check whether this map contains any key-value mappings.</li>
</ul>
<p>以上类型的状态都有相同的方法clear()用来清除当前key对应的状态。</p>
<h2 id="Operator-State"><a href="#Operator-State" class="headerlink" title="Operator State"></a>Operator State</h2><p>​		在Flink中，状态始终与特定算子相关联，</p>
<p>Operator State 算子状态</p>
<p>算子状态限定为算子任务，由同一并行任务所处理的所有数据都可以访问到相同的状态</p>
<p>状态对于同一子任务是共享的</p>
<p>算子状态不能由相同或不同的算子的另一个子任务访问</p>
<h2 id="Broadcast-State"><a href="#Broadcast-State" class="headerlink" title="Broadcast State"></a>Broadcast State</h2><h1 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h1><ul>
<li>一致性检查点</li>
<li>从检查点恢复状态</li>
<li>Flink检查点算法</li>
<li>保存点（Save Points）</li>
</ul>
<p>Flink故障恢复机制的核心，就是应用状态的一致性检查点</p>
<p>有状态流应用的一致性检查点，就是所有任务的状态，在摸一个时间点的一份拷贝（快照）；在这个时间点，应该是所有的任务陡峭好处理完一个相同的输入数据的时候。</p>
<p>错误重启策略:</p>
<p>不重启</p>
<p>固定频率重启</p>
<p>失败率重启</p>
<p>保存点（Savepoint）</p>
<ul>
<li><p>Flink提供可以自定义的镜像保存功能，就是保存点。</p>
</li>
<li><p>原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为是具有一些额外元数据的检查点。</p>
</li>
<li><p>Flink不会自动创建保存点，因此用户(或外部调用程序)必须明确地触发创建操作</p>
</li>
<li><p>保存点是一个强大的功能，除了故障恢复外，</p>
<p>  保存点可以用于：</p>
<ul>
<li><p>有计划的手动备份  程序运行到一定程度的时候，可以手动备份下比较重要的结果</p>
</li>
<li><p>更新应用程序   更新程序后，重新从保存点开始继续执行，而不需要在更新之后重新计算</p>
</li>
<li><p>版本迁移 例如升级Flink版本，程序版本等</p>
</li>
<li><p>暂停和重重启应用</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.enableCheckpointing(<span class="type">long</span> interval))</span><br></pre></td></tr></table></figure>





<h1 id="Table-API-Table-SQL"><a href="#Table-API-Table-SQL" class="headerlink" title="Table API &amp; Table SQL"></a>Table API &amp; Table SQL</h1><h2 id="入门代码样例"><a href="#入门代码样例" class="headerlink" title="入门代码样例"></a>入门代码样例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableTest1_Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; inputStream = env.readTextFile(<span class="string">&quot;src/main/resources/sensor.txt&quot;</span>);</span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; dataStream = inputStream.map(v -&gt; &#123;</span><br><span class="line">            String[] fields = v.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.valueOf(fields[<span class="number">1</span>]), Double.valueOf(fields[<span class="number">2</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建表环境</span></span><br><span class="line">        <span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过流创建建一张表</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">dataTable</span> <span class="operator">=</span> tableEnv.fromDataStream(dataStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Table API进行算子操作</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">resultTable</span> <span class="operator">=</span> dataTable.select(<span class="string">&quot;id, temperature&quot;</span>).where(<span class="string">&quot;id = &#x27;sensor_1&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Table SQL进行操作</span></span><br><span class="line">        <span class="comment">// 创建一张表</span></span><br><span class="line">        tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, dataStream);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, temperature from sensor where id = &#x27;sensor_1&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">Table</span> <span class="variable">sqlResult</span> <span class="operator">=</span> tableEnv.sqlQuery(sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Table转换成流stream</span></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        tableEnv.toAppendStream(sqlResult,Row.class).print(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>输出到文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableTest3_FileOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 表的创建：连接外部系统，读取数据</span></span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;src\\main\\resources\\sensor.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册定义的表</span></span><br><span class="line">        tableEnv.connect( <span class="keyword">new</span> <span class="title class_">FileSystem</span>().path(filePath))</span><br><span class="line">                .withFormat( <span class="keyword">new</span> <span class="title class_">Csv</span>())</span><br><span class="line">                .withSchema( <span class="keyword">new</span> <span class="title class_">Schema</span>()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                        .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">                        .field(<span class="string">&quot;temp&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">                )</span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Table</span> <span class="variable">inputTable</span> <span class="operator">=</span> tableEnv.from(<span class="string">&quot;inputTable&quot;</span>);</span><br><span class="line"><span class="comment">//        inputTable.printSchema();</span></span><br><span class="line"><span class="comment">//        tableEnv.toAppendStream(inputTable, Row.class).print(&quot;inputTable&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 查询转换</span></span><br><span class="line">        <span class="comment">// 3.1 Table API</span></span><br><span class="line">        <span class="comment">// 简单转换</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">resultTable</span> <span class="operator">=</span> inputTable.select(<span class="string">&quot;id, temp&quot;</span>)</span><br><span class="line">                .filter(<span class="string">&quot;id === &#x27;sensor_6&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 聚合统计</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">aggTable</span> <span class="operator">=</span> inputTable.groupBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .select(<span class="string">&quot;id, id.count as count, temp.avg as avgTemp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 SQL</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">sqlResult</span> <span class="operator">=</span> tableEnv.sqlQuery(<span class="string">&quot;select id, temp from inputTable where id = &#x27;sensor_6&#x27;&quot;</span>);</span><br><span class="line">        <span class="type">Table</span> <span class="variable">sqlAggTable</span> <span class="operator">=</span> tableEnv.sqlQuery(<span class="string">&quot;select id, count(id) as cnt, avg(temp) as avgTemp from inputTable group by id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 输出到文件</span></span><br><span class="line">        <span class="comment">// 连接外部文件注册输出表</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">outputPath</span> <span class="operator">=</span> <span class="string">&quot;src\\main\\resources\\out.txt&quot;</span>;</span><br><span class="line">        tableEnv.connect( <span class="keyword">new</span> <span class="title class_">FileSystem</span>().path(outputPath))</span><br><span class="line">                .withFormat( <span class="keyword">new</span> <span class="title class_">Csv</span>())</span><br><span class="line">                .withSchema( <span class="keyword">new</span> <span class="title class_">Schema</span>()</span><br><span class="line">                        .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line"><span class="comment">//                        .field(&quot;cnt&quot;, DataTypes.BIGINT())</span></span><br><span class="line">                        .field(<span class="string">&quot;temperature&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">                )</span><br><span class="line">                .createTemporaryTable(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tableEnv.toAppendStream(resultTable, Row.class).print(<span class="string">&quot;resultTable&quot;</span>);</span><br><span class="line">        resultTable.executeInsert(<span class="string">&quot;outputTable&quot;</span>);</span><br><span class="line"><span class="comment">//        aggTable.insertInto(&quot;outputTable&quot;);</span></span><br><span class="line"><span class="comment">//        tableEnv.toRetractStream(aggTable, Row.class).print();</span></span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>aggTable.insertInto(“outputTable”)这行代码会报错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.apache.flink.table.api.TableException: AppendStreamTableSink doesn&#x27;t support consuming update changes which is produced by node GroupAggregate(groupBy=[id], select=[id, COUNT(id) AS cnt, AVG(temp) AS avgTemp])</span><br><span class="line">	at org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.createNewNode(FlinkChangelogModeInferenceProgram.scala:357)</span><br><span class="line">	at org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.visit(FlinkChangelogModeInferenceProgram.scala:174)</span><br><span class="line">	at org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.visitChild(FlinkChangelogModeInferenceProgram.scala:314)</span><br><span class="line">	at org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.$anonfun$visitChildren$1(FlinkChangelogModeInferenceProgram.scala:303)</span><br><span class="line">	at org.apache.flink.table.planner.plan.optimize.program.FlinkChangelogModeInferenceProgram$SatisfyModifyKindSetTraitVisitor.$anonfun$visitChildren$1$adapted(FlinkChangelogModeInferenceProgram.scala:302)</span><br><span class="line">	at scala.collection.TraversableLike.$anonfun$map$1(TraversableLike.scala:233)</span><br><span class="line">	at scala.collection.immutable.Range.foreach(Range.scala:155)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>这段代码为什么会报错?</p>
<p>它具体的操作是需要对流中的数据做聚合操作然后更新计算结果，而流中的数据是无法回撤更新的，例如接收到同一个key的第二条数据时，计算的结果会发生变化，但却不能再回去修改了。</p>
<p>使用下面这个方法结果为一个二元组，它的第一个元素表示这条记录是否需要撤回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.toRetractStream(aggTable, Row.class).print();</span><br></pre></td></tr></table></figure>

<p><img src="/flink%E7%AC%94%E8%AE%B0.assets/image-20211208011201234.png" alt="image-20211208011201234"></p>
<p>第一次接收到sensor_4时，计算结果为(true, sensor_4,35.2)；</p>
<p>第二次接收到sensor_4时，需要更新计算结果哦，于是会将上次的结果变为(false, sensor_4,35.2)，表示这条记录需要回撤，并且给出新的计算结果(true,sensor_4,2,34.900000000000006)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/05/flink/flink%E7%AC%94%E8%AE%B0/" data-id="clumsd6x50007abr72zpc8w4a" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/04/05/flink/Flink%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8(scala%E7%89%88)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2024/04/05/docker/Docker%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8mongo/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/05/%E6%95%B0%E4%BB%93%E7%BB%8F%E9%AA%8C/%E9%9D%A2%E8%AF%95%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/05/zookeeper/Zookeeper/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/05/zookeeper/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA(HA)/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/05/spark/spark%E7%BC%96%E7%A8%8B-RDD%E9%AB%98%E9%98%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/04/05/spark/spark%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>